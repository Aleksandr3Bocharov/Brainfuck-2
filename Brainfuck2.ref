* Copyright 2023 Aleksandr Bocharov
* Distributed under the Boost Software License, Version 1.0.
* See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt
* 2023-07-01
* https://github.com/Aleksandr3Bocharov/Brainfuck-2

/* 

Brainfuck 2

Программа "Brainfuck 2" написана на языке программирования Рефал-5λ.
https://github.com/bmstu-iu9/refal-5-lambda

Программа "Brainfuck 2" интерпретирует код на языке Brainfuck из исходного файла 'filename.bf'
и компилирует его в код на языке C в файл назначения 'filename.bf.c'.


ИСПОЛЬЗОВАНИЕ:
    brainfuck2 [filename[.bf]]


где
    filename        Имя исходного файла и файла назначения.


Имя по умолчанию исходного файла 'brainfuck.bf'
и файла назначения 'brainfuck.bf.c'.


Если исходный файл 'filename.bf' не существует,
то происходит FATAL_ERROR(1) и программа завершает работу.


Файл назначения 'filename.bf.c' будет перезаписан, если он существует.



*/

*$FROM LibraryEx
$EXTERN Fetch, Pipe, Map, MapAccum, DelAccumulator, LoadFile, SaveFile, Inc, Dec, TermCompare;

%%
#include <stdio.h>
#include <conio.h>
%%

/* 

<Putchar e.Char> == * empty *

e.Char ::= s.CHAR? | s.CHAR e.ANY-EXPR

*/
Putchar {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  int putchar_res = 0;
  refalrts::Iter p = content_b, end = content_e;
  
  if (! refalrts::empty_seq(p, end)) 
  {
    switch(p->tag) 
	  {
      case refalrts::cDataChar:
        putchar_res = printf("%c", p->char_info);
		    break;

      default:
	      return refalrts::cRecognitionImpossible;
    }
  }

  if (putchar_res < 0) 
  {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

/*

<Getch> == s.Char

s.Char ::= s.CHAR

*/
Getch {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);
	
  if (! refalrts::empty_seq(content_b, content_e)) 
  {
    return refalrts::cRecognitionImpossible;
  }
	
  refalrts::reset_allocator(vm);
  refalrts::Iter dummy = 0;

  int cur_char;
  cur_char = getche();
  refalrts::alloc_char(vm, dummy, static_cast<char>(cur_char));

  refalrts::splice_from_freelist(vm, arg_begin);
  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

/*

<RU e.String> == e.String

e.String ::= s.CHAR*

*/
RU {
    /* empty */ = /* empty */;
    'Ё' e.RestChars =
      <Chr 240> <RU e.RestChars>;
    'ё' e.RestChars =
      <Chr 241> <RU e.RestChars>;
    s.Char1 s.Char2 e.RestChars,
    <isRU s.Char1 s.Char2>:208 =
      <Chr <Sub <Ord s.Char2> 16>> <RU e.RestChars>;
    s.Char1 s.Char2 e.RestChars,
    <isRU s.Char1 s.Char2>:209 =
      <Chr <Add <Ord s.Char2> 96>> <RU e.RestChars>;
    s.Char e.RestChars =
      s.Char <RU e.RestChars>;
  }
  
  /*
  
  <isRU e.Char> == s.isRU
  
  e.Char ::= s.CHAR s.CHAR
  s.isRU ::= 208 | 209 | False
  
  */
  isRU {
    e.Char,
    <Compare (<Ord e.Char>) 208 143>: '+',
    <Compare (<Ord e.Char>) 208 192>: '-' =
      208;
    e.Char,
    <Compare (<Ord e.Char>) 209 127>: '+',
    <Compare (<Ord e.Char>) 209 144>: '-' =
      209;
    e.Char =
      False
  }

* Вывод справки
Help {
  = <Prout
      <RU
        '\nПрограмма "Brainfuck 2" интерпретирует код на языке Brainfuck из исходного файла \'filename.bf\'\n'
        'и компилирует его в код на языке C в файл назначения \'filename.bf.c\'.\n\n\n'
        'ИСПОЛЬЗОВАНИЕ:\n'
        '    brainfuck2 [filename[.bf]]\n\n\n'
        'где\n'
        '    filename        Имя исходного файла и файла назначения.\n\n\n'
        'Имя по умолчанию исходного файла \'brainfuck.bf\'\n'
        'и файла назначения \'brainfuck.bf.c\'.\n\n\n'
        'Если исходный файл \'filename.bf\' не существует,\n'
        'то происходит FATAL_ERROR(1) и программа завершает работу.\n\n\n'
        'Файл назначения \'filename.bf.c\' будет перезаписан, если он существует.\n\n\n'
      >
    >
}

/*

<Interpretator e.Parsing_Tree> == 

e.Parsing_Tree ::= e.Token*
e.Token ::= Next | Prev | Inc | Dec | Print | Read | Open s.BracketLevel | Close s.BracketLevel
s.BracketLevel ::= s.NUMBER

*/
Interpretator {
  e.Parsing_Tree =
    <DoInterpretator e.Parsing_Tree () 0 ()>: e._ =
}

/*

<DoInterpretator e.Parsing_Tree (e.BeforeCells) s.Cell (e.AfterCells)> ==

e.Parsing_Tree ::= e.Token*
e.Token ::= Next | Prev | Inc | Dec | Print | Read | Open s.BracketLevel | Close s.BracketLevel
s.BracketLevel ::= s.NUMBER
e.BeforeCells, e.AfterCells ::= s.NUMBER*
s.Cell ::= s.NUMBER

*/
DoInterpretator {
  (e.BeforeCells) s.Cell (e.AfterCells) =
    (e.BeforeCells) s.Cell (e.AfterCells);
  Next e.Rest_Parsing_Tree (e.BeforeCells) s.Cell () =
    <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells s.Cell) 0 ()>;
  Next e.Rest_Parsing_Tree (e.BeforeCells) s.Cell (s.NextCell e.AfterCells) =
    <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells s.Cell) s.NextCell (e.AfterCells)>;    
  Prev e.Rest_Parsing_Tree () s.Cell (e.AfterCells) =
    <DoInterpretator e.Rest_Parsing_Tree () 0 (s.Cell e.AfterCells)>;
  Prev e.Rest_Parsing_Tree (e.BeforeCells s.PrevCell) s.Cell (e.AfterCells) =
    <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) s.PrevCell (s.Cell e.AfterCells)>;    
  Inc e.Rest_Parsing_Tree (e.BeforeCells) 255 (e.AfterCells) =
    <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) 0 (e.AfterCells)>;
  Inc e.Rest_Parsing_Tree (e.BeforeCells) s.Cell (e.AfterCells) =
    <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) <Inc s.Cell> (e.AfterCells)>;     							
  Dec e.Rest_Parsing_Tree (e.BeforeCells) 0 (e.AfterCells) =
    <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) 255 (e.AfterCells)>;
  Dec e.Rest_Parsing_Tree (e.BeforeCells) s.Cell (e.AfterCells) =
    <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) <Dec s.Cell> (e.AfterCells)>;    
  Print e.Rest_Parsing_Tree (e.BeforeCells) s.Cell (e.AfterCells) =
    <Putchar <Chr s.Cell>> 
    <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) s.Cell (e.AfterCells)>;												
  Read e.Rest_Parsing_Tree (e.BeforeCells) s._ (e.AfterCells) =
    <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) <Ord <Getch>> (e.AfterCells)>;						
  Open s.BracketLevel e.OpenClose Close s.BracketLevel e.Rest_Parsing_Tree
    (e.BeforeCells) 0 (e.AfterCells) =
      <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) 0 (e.AfterCells)>;
  Open s.BracketLevel e.OpenClose Close s.BracketLevel e.Rest_Parsing_Tree 
    (e.BeforeCells) s.Cell (e.AfterCells) =
    <DoInterpretator e.OpenClose (e.BeforeCells) s.Cell (e.AfterCells)>: e.Cells =
    <DoInterpretator Open s.BracketLevel e.OpenClose Close s.BracketLevel e.Rest_Parsing_Tree e.Cells>   
}

/*

<CompiletoC e.Parsing_Tree> == t.C_Code

e.Parsing_Tree ::= e.Token*
e.Token ::= Next | Prev | Inc | Dec | Print | Read | Open s.BracketLevel | Close s.BracketLevel
s.BracketLevel ::= s.NUMBER
t.C_Code ::= (s.CHAR+)

*/
CompiletoC {
  e.Parsing_Tree =
    (
      '#include <memory.h>\n'
      '#include <stdio.h>\n\n'
      'int main(void)\n'
      '{\n'
      '     int i = 0;\n'
      '     unsigned char arr[30000];\n'
      '     memset(arr, 0, sizeof(arr));\n'
      <DoCompiletoC ('     ') e.Parsing_Tree>
      '}'
    )	
}

DoCompiletoC {
  (e.Spaces) /* empty */ =
    /* empty */;
  (e.Spaces) Next e.Rest_Parsing_Tree =
    e.Spaces 'i++;\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Prev e.Rest_Parsing_Tree =
    e.Spaces 'i--;\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Inc e.Rest_Parsing_Tree =
    e.Spaces 'arr[i]++;\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Dec e.Rest_Parsing_Tree =
    e.Spaces 'arr[i]--;\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Print e.Rest_Parsing_Tree =
    e.Spaces 'putchar(arr[i]);\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Read e.Rest_Parsing_Tree =
    e.Spaces 'arr[i] = getchar();\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Open s.BracketLevel e.OpenClose Close s.BracketLevel e.Rest_Parsing_Tree =
    e.Spaces 'while(arr[i])\n' 
    e.Spaces '{\n' 
    <DoCompiletoC (e.Spaces '     ') e.OpenClose>
    e.Spaces '}\n' 
    <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>
}

/* 

<Parser e.Symbols> == e.Parsing_Tree | Fails e.Errors

e.Symbols ::= (s.Char s.Row s.Col)* 
s.Char ::= s.CHAR
s.Row, s.Col ::= s.NUMBER
e.Parsing_Tree ::= e.Token*
e.Token ::= Next | Prev | Inc | Dec | Print | Read | Open s.BracketLevel | Close s.BracketLevel
s.BracketLevel ::= s.NUMBER
e.Errors ::= (e.ErrorMessage)+
e.ErrorMessage ::= s.CHAR+

*/
Parser {
  e.Symbols =
    <Br Fails11 '=' >
    <Br Fails12 '=' >
    <MapAccum 
      {
        s.BracketLevel ('[' s.Row s.Col) =
          <Inc s.BracketLevel>
          <Rp Fails12 '=' <Cp Fails12> (<RU 'SYNTAX_ERROR(12): Отсутствует символ \']\' для символа \'[\' в строке: '> s.Row <RU ' и столбце: '> s.Col '.')>
          Open  <Inc s.BracketLevel>;
        s.BracketLevel (']' s.Row s.Col),
        <TermCompare (<Cp Fails12>) ()>: '=' =
          s.BracketLevel
          <Rp Fails11 '=' <Cp Fails11> (<RU 'SYNTAX_ERROR(11): Непредвиденный символ \']\' в строке: '> s.Row <RU ' и столбце: '> s.Col '.')>
            ; 
        s.BracketLevel (']' s.Row s.Col),
        <Cp Fails12>: e.Fails12 (e._) =
          <Dec s.BracketLevel>
          <Rp Fails12 '=' e.Fails12>
          Close  s.BracketLevel;   
        s.BracketLevel ('>' e._) = 
          s.BracketLevel
          Next; 
        s.BracketLevel ('<' e._) =
          s.BracketLevel
          Prev; 
        s.BracketLevel ('+' e._) =
          s.BracketLevel
          Inc; 
        s.BracketLevel ('-' e._) =
          s.BracketLevel
          Dec;
        s.BracketLevel ('.' e._) =
          s.BracketLevel
          Print;
        s.BracketLevel (',' e._) =
          s.BracketLevel
          Read;
        s.BracketLevel (s._ e._) =
          s.BracketLevel
          /* empty */
      } 
      0
      e.Symbols
    >:
    {
      s._ e.Parsing_Tree,
      <TermCompare (<Cp Fails11>) ()>: '=',
      <TermCompare (<Cp Fails12>) ()>: '=' =
        e.Parsing_Tree
        <Rp Fails11 '=' >
        <Rp Fails12 '=' >
        <Dg Fails11>
        <Dg Fails12>;
      s._ e._ =
        Fails
        <Cp Fails11>
        <Cp Fails12>
        <Rp Fails11 '=' >
        <Rp Fails12 '=' >
        <Dg Fails11>
        <Dg Fails12>
    }
}
	
$ENTRY Go {
  =
    /* Аргумент программы - имя файла, где находится код Brainfuck.*/
    <Arg 1>: 
    /* По умолчанию имя файла - 'brainfuck.bf'. Можно в конце имени файла не добавлять расширение .bf */				
    { 
      /* empty */ =
        'brainfuck.bf';
      e.FileName '.bf' =
        e.FileName '.bf';
      e.FileName =
        e.FileName '.bf'
    }:
    e.bfFileName =
    <Help>
    <Prout <RU 'Код на языке Brainfuck из исходного файла '> e.bfFileName ':\n'>
    <Fetch
      e.bfFileName			
      <Pipe 
        /* Если файл не существует, то выход из программы. */
        ExistFile
        {
          True =
            e.bfFileName;
          False =
            <Prout <RU 'FATAL_ERROR (1): Файл '> e.bfFileName <RU ' не существует.'>>
            <Exit 1>
        }
        /* Загрузка строк файла в e.Lines ::= (e.Line)*;  e.Line ::= s.CHAR* */
        LoadFile
        /* Вывод строк файла на консоль и преобразование строк e.Lines => e.Symbols
        e.Symbols ::= (s.Char s.Row s.Col)*; s.Char ::= s.CHAR; s.Row ::= s.NUMBER; s.Col  ::= s.NUMBER */
        (
          MapAccum 
            {
              s.Row (e.Line) =
                <Inc s.Row> 
                <Prout s.Row ' ' e.Line>
                <Fetch
                  e.Line
                  <Pipe
                    (MapAccum {s.Col s.Char = <Inc s.Col> (s.Char s.Row s.Col)} 1)
                    DelAccumulator
                  >
                >	
            }
            1
        )
        DelAccumulator
        /* Запуск лексического и синтаксического анализатора */
        &Parser
        {
          /* Если Fails, то завершение программы */
          Fails e.Errors =	
            <Map {(e.ErrorMessage) = <Prout e.ErrorMessage>} e.Errors> 
            <Prout <RU 'FATAL_ERROR (99): Существуют несколько синтаксических ошибок.'>>
            <Exit 99>;
          e.Parsing_Tree = 
            <Fetch
              e.Parsing_Tree
              <Pipe 
                /* Запуск компилятора в код C */
                &CompiletoC
                /* Сохранение кода C в файл */
                (SaveFile (e.bfFileName '.c'))
                /* Запуск интерпретатора */
                Prout
                (&Interpretator e.Parsing_Tree)
              >
            >
        }
      >
    >
}
