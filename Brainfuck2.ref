* Copyright 2023 Aleksandr Bocharov
* Distributed under the Boost Software License, Version 1.0.
* See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt
* 2023-06-10
* https://github.com/Aleksandr3Bocharov/Brainfuck-2

/* 

Brainfuck 2

Программа "Brainfuck 2" написана на языке программирования Рефал-5λ.
https://github.com/bmstu-iu9/refal-5-lambda

Для компиляции программы нужны модули "stdio.ref и "Vector.ref" из
Библиотеки модулей для языка программирования Рефал-5λ.
https://github.com/Aleksandr3Bocharov/Libs-for-Refal-5-Lambda

Программа "Brainfuck 2" интерпретирует код на языке Brainfuck из исходного файла 'filename.bf'
и компилирует его в код на языке C в файл назначения 'filename.bf.c'.


ИСПОЛЬЗОВАНИЕ:
    brainfuck2 [filename[.bf]]


где
    filename        Имя исходного файла и файла назначения.


Имя по умолчанию исходного файла 'brainfuck.bf'
и файла назначения 'brainfuck.bf.c'.


Если исходный файл 'filename.bf' не существует,
то происходит FATAL_ERROR(1) и программа завершает работу.


Файл назначения 'filename.bf.c' будет перезаписан, если он существует.



*/

*$FROM LibraryEx
$EXTERN Fetch, Pipe, Map, MapAccum, DelAccumulator, LoadFile, SaveFile, Inc, Dec;

*$FROM stdio
$EXTERN Putchar, Getchar, RU;

*$FROM Vector
$EXTERN CVector;


* Вывод справки
Help {
  = <Prout
      <RU
        '\nПрограмма "Brainfuck 2" интерпретирует код на языке Brainfuck из исходного файла \'filename.bf\'\n'
        'и компилирует его в код на языке C в файл назначения \'filename.bf.c\'.\n\n\n'
        'ИСПОЛЬЗОВАНИЕ:\n'
        '    brainfuck2 [filename[.bf]]\n\n\n'
        'где\n'
        '    filename        Имя исходного файла и файла назначения.\n\n\n'
        'Имя по умолчанию исходного файла \'brainfuck.bf\'\n'
        'и файла назначения \'brainfuck.bf.c\'.\n\n\n'
        'Если исходный файл \'filename.bf\' не существует,\n'
        'то происходит FATAL_ERROR(1) и программа завершает работу.\n\n\n'
        'Файл назначения \'filename.bf.c\' будет перезаписан, если он существует.\n\n\n'
      >
    >
}

/*

<Interpretator e.Parsing_Tree> == 

e.Parsing_Tree ::= e.Token*
e.Token ::= Next | Prev | Inc | Dec | Print | Read | Open s.BracketLevel | Close s.BracketLevel
s.BracketLevel ::= s.NUMBER

*/
Interpretator {
  e.Parsing_Tree =
    <CVector Cells (1 '('0')')>
    <Br CurrentCell '=' <CVector Cells Begin>>
    <DoInterpretator e.Parsing_Tree>
    <Rp CurrentCell '=' >
    <Dg CurrentCell>
    <CVector Cells '~'>
}

/*

<DoInterpretator e.Parsing_Tree> ==

e.Parsing_Tree ::= e.Token*
e.Token ::= Next | Prev | Inc | Dec | Print | Read | Open s.BracketLevel | Close s.BracketLevel
s.BracketLevel ::= s.NUMBER

*/
DoInterpretator {
  /* empty */ = /* empty */;
  Next e.Rest_Parsing_Tree =
    <CVector Cells Iterator '++'<Cp CurrentCell>>:
    {
      s.NextCurrentCell,
      <CVector Cells Iterator s.NextCurrentCell '==' <CVector Cells End>>: True = 
       <Rp CurrentCell '=' <CVector Cells Insert s.NextCurrentCell '('0')'>>
       <DoInterpretator e.Rest_Parsing_Tree>;
      s.NextCurrentCell =  
        <Rp CurrentCell '=' s.NextCurrentCell>
        <DoInterpretator e.Rest_Parsing_Tree>
    };    
  Prev e.Rest_Parsing_Tree =
    <Cp CurrentCell>:
    {
      s.CurrentCell,
      <CVector Cells Iterator s.CurrentCell '==' <CVector Cells Begin>>: True = 
        <Rp CurrentCell '=' <CVector Cells Insert <CVector Cells Begin> '('0')'>>
        <DoInterpretator e.Rest_Parsing_Tree>;
      s.CurrentCell =
        <Rp CurrentCell '=' <CVector Cells Iterator '--'s.CurrentCell>>
        <DoInterpretator e.Rest_Parsing_Tree>
    };    
  Inc e.Rest_Parsing_Tree =
    <Cp CurrentCell>: s.CurrentCell =
    <CVector Cells Iterator '*'s.CurrentCell>:
    {
      255 =
        <CVector Cells Iterator '*'s.CurrentCell '=' '('0')'>
        <DoInterpretator e.Rest_Parsing_Tree>; 
      s.CurrentCellValue =
        <CVector Cells  Iterator '*'s.CurrentCell '=' '('<Inc s.CurrentCellValue>')'>
        <DoInterpretator e.Rest_Parsing_Tree>
    };     							
  Dec e.Rest_Parsing_Tree =
    <Cp CurrentCell>: s.CurrentCell =
    <CVector Cells Iterator '*'s.CurrentCell>:
    {
      0 =
        <CVector Cells Iterator '*'s.CurrentCell '=' '('255')'>
        <DoInterpretator e.Rest_Parsing_Tree>; 
      s.CurrentCellValue =
        <CVector Cells  Iterator '*'s.CurrentCell '=' '('<Dec s.CurrentCellValue>')'>
        <DoInterpretator e.Rest_Parsing_Tree>
    };  
  Print e.Rest_Parsing_Tree =
    <Putchar <Chr <CVector Cells  Iterator '*'<Cp CurrentCell>>>> 
    <DoInterpretator e.Rest_Parsing_Tree>;												
  Read e.Rest_Parsing_Tree =
    <CVector Cells  Iterator '*'<Cp CurrentCell> '=' '('<Ord <Getchar>>')'>
    <DoInterpretator e.Rest_Parsing_Tree>;						
  Open s.BracketLevel e.OpenClose Close s.BracketLevel e.Rest_Parsing_Tree,
  <CVector Cells  Iterator '*'<Cp CurrentCell>>: 0 =
    <DoInterpretator e.Rest_Parsing_Tree>;
  Open s.BracketLevel e.OpenClose Close s.BracketLevel e.Rest_Parsing_Tree =
    <DoInterpretator e.OpenClose>
    <DoInterpretator Open s.BracketLevel e.OpenClose Close s.BracketLevel e.Rest_Parsing_Tree>   
}

/*

<CompiletoC e.Parsing_Tree> == t.C_Code

e.Parsing_Tree ::= e.Token*
e.Token ::= Next | Prev | Inc | Dec | Print | Read | Open s.BracketLevel | Close s.BracketLevel
s.BracketLevel ::= s.NUMBER
t.C_Code ::= (s.CHAR+)

*/
CompiletoC {
  e.Parsing_Tree =
    (
      '#include <memory.h>\n'
      '#include <stdio.h>\n\n'
      'int main(void)\n'
      '{\n'
      '     int i = 0;\n'
      '     unsigned char arr[30000];\n'
      '     memset(arr, 0, sizeof(arr));\n'
      <DoCompiletoC ('     ') e.Parsing_Tree>
      '}'
    )	
}

DoCompiletoC {
  (e.Spaces) /* empty */ =
    /* empty */;
  (e.Spaces) Next e.Rest_Parsing_Tree =
    e.Spaces 'i++;\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Prev e.Rest_Parsing_Tree =
    e.Spaces 'i--;\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Inc e.Rest_Parsing_Tree =
    e.Spaces 'arr[i]++;\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Dec e.Rest_Parsing_Tree =
    e.Spaces 'arr[i]--;\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Print e.Rest_Parsing_Tree =
    e.Spaces 'putchar(arr[i]);\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Read e.Rest_Parsing_Tree =
    e.Spaces 'arr[i] = getchar();\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Open s.BracketLevel e.OpenClose Close s.BracketLevel e.Rest_Parsing_Tree =
    e.Spaces 'while(arr[i])\n' 
    e.Spaces '{\n' 
    <DoCompiletoC (e.Spaces '     ') e.OpenClose>
    e.Spaces '}\n' 
    <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>
}

/* 

<Parser e.Symbols> == e.Parsing_Tree | Fails e.Errors

e.Symbols ::= (s.Char s.Row s.Col)* 
s.Char ::= s.CHAR
s.Row, s.Col ::= s.NUMBER
e.Parsing_Tree ::= e.Token*
e.Token ::= Next | Prev | Inc | Dec | Print | Read | Open s.BracketLevel | Close s.BracketLevel
s.BracketLevel ::= s.NUMBER
e.Errors ::= (e.ErrorMessage)+
e.ErrorMessage ::= s.CHAR+

*/
Parser {
  e.Symbols =
    <CVector Vector11 ()>
    <CVector Vector12 ()>
    <MapAccum 
      {
        s.BracketLevel ('[' s.Row s.Col) =
          <Inc s.BracketLevel>
          <CVector Vector12 Push_Back '('<RU 'SYNTAX_ERROR(12): Отсутствует символ \']\' для символа \'[\' на строке: '> s.Row <RU ', столбце: '> s.Col '.'')'>
          Open  <Inc s.BracketLevel>;
        s.BracketLevel (']' s.Row s.Col),
        <CVector Vector12 Size>: 0 =
          s.BracketLevel
          <CVector Vector11 Push_Back '('<RU 'SYNTAX_ERROR(11): Непредвиденный символ \']\' на строке: '> s.Row <RU ', столбце: '> s.Col '.'')'>
          /* empty */; 
        s.BracketLevel (']' s.Row s.Col) =
          <Dec s.BracketLevel>
          <CVector Vector12 Pop_Back>
          Close  s.BracketLevel;   
        s.BracketLevel ('>' e._) = 
          s.BracketLevel
          Next; 
        s.BracketLevel ('<' e._) =
          s.BracketLevel
          Prev; 
        s.BracketLevel ('+' e._) =
          s.BracketLevel
          Inc; 
        s.BracketLevel ('-' e._) =
          s.BracketLevel
          Dec;
        s.BracketLevel ('.' e._) =
          s.BracketLevel
          Print;
        s.BracketLevel (',' e._) =
          s.BracketLevel
          Read;
        s.BracketLevel (s._ e._) =
          s.BracketLevel
          /* empty */
      } 
      0
      e.Symbols
    >:
    {
      s._ e.Parsing_Tree,
      <CVector Vector11 Size>: 0,
      <CVector Vector12 Size>: 0 =
        e.Parsing_Tree;
      s._ e._ =
        Fails
        <CVector Vector11>
        <CVector Vector12>
    }: e.ParserResult = 
      e.ParserResult
      <CVector Vector11 '~'>
      <CVector Vector12 '~'>
}
	
$ENTRY Go {
  =
    /* Аргумент программы - имя файла, где находится код Brainfuck.*/
    <Arg 1>: 
    /* По умолчанию имя файла - 'brainfuck.bf'. Можно в конце имени файла не добавлять расширение .bf */				
    { 
      /* empty */ =
        'brainfuck.bf';
      e.FileName '.bf' =
        e.FileName '.bf';
      e.FileName =
        e.FileName '.bf'
    }:
    e.bfFileName =
    <Help>
    <Prout <RU 'Код на языке Brainfuck из исходного файла '> e.bfFileName ':\n'>
    <Fetch
      e.bfFileName			
      <Pipe 
        /* Если файл не существует, то выход из программы. */
        ExistFile
        {
          True =
            e.bfFileName;
          False =
            <Prout <RU 'FATAL_ERROR (1): Файл '> e.bfFileName <RU ' не существует.'>>
            <Exit 1>
        }
        /* Загрузка строк файла в e.Lines ::= (e.Line)*;  e.Line ::= s.CHAR* */
        LoadFile
        /* Вывод строк файла на консоль и преобразование строк e.Lines => e.Symbols
        e.Symbols ::= (s.Char s.Row s.Col)*; s.Char ::= s.CHAR; s.Row ::= s.NUMBER; s.Col  ::= s.NUMBER */
        (
          MapAccum 
            {
              s.Row (e.Line) =
                <Inc s.Row> 
                <Prout s.Row ' ' e.Line>
                <Fetch
                  e.Line
                  <Pipe
                    (MapAccum {s.Col s.Char = <Inc s.Col> (s.Char s.Row s.Col)} 1)
                    DelAccumulator
                  >
                >	
            }
            1
        )
        DelAccumulator
        /* Запуск лексического и синтаксического анализатора */
        &Parser
        {
          /* Если Fails, то завершение программы */
          Fails e.Errors =	
            <Map {(e.ErrorMessage) = <Prout e.ErrorMessage>} e.Errors> 
            <Prout <RU 'FATAL_ERROR (99): Существуют несколько синтаксических ошибок.'>>
            <Exit 99>;
          e.Parsing_Tree = 
            <Fetch
              e.Parsing_Tree
              <Pipe 
                /* Запуск компилятора в код C */
                &CompiletoC
                /* Сохранение кода C в файл */
                (SaveFile (e.bfFileName '.c'))
                /* Запуск интерпретатора */
                Prout
                (&Interpretator e.Parsing_Tree)
              >
            >
        }
      >
    >
}
