* Copyright 2023 Aleksandr Bocharov
* Distributed under the Boost Software License, Version 1.0.
* See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt
* 2023-05-23

/* 

Brainfuck 2

Программа "Brainfuck 2" написана на языке программирования Рефал-5-Лямбда.
https://github.com/bmstu-iu9/refal-5-lambda

Программа "Brainfuck 2" интерпретирует код на языке Brainfuck из исходного файла 'filename.bf'
и компилирует его в код на языке C в файл назначения 'filename.bf.c'.


ИСПОЛЬЗОВАНИЕ:
    brainfuck2 [filename[.bf]]


где
    filename        Имя исходного файла и файла назначения.


Имя по умолчанию исходного файла 'brainfuck.bf'
и файла назначения 'brainfuck.bf.c'.


Если исходный файл 'filename.bf' не существует,
то происходит FATAL_ERROR(1) и программа завершает работу.


Файл назначения 'filename.bf.c' будет перезаписан, если он существует.



*/

*$FROM LibraryEx
$EXTERN Fetch, Pipe, Map, Reduce, MapAccum, DelAccumulator, LoadFile, SaveFile, Inc, Dec;

*$FROM stdio
$EXTERN Putchar, Getchar, RU;

*$FROM Vector
$EXTERN VectorNew, VectorSet, VectorGet, VectorPushFirst,
VectorPushLast, VectorPopLast, VectorLength, VectorGetAll;


* Вывод справки
Help {
  = <Prout
      <RU
        '\nПрограмма "Brainfuck 2" интерпретирует код на языке Brainfuck из исходного файла \'filename.bf\'\n'
        'и компилирует его в код на языке C в файл назначения \'filename.bf.c\'.\n\n\n'
        'ИСПОЛЬЗОВАНИЕ:\n'
        '    brainfuck2 [filename[.bf]]\n\n\n'
        'где\n'
        '    filename        Имя исходного файла и файла назначения.\n\n\n'
        'Имя по умолчанию исходного файла \'brainfuck.bf\'\n'
        'и файла назначения \'brainfuck.bf.c\'.\n\n\n'
        'Если исходный файл \'filename.bf\' не существует,\n'
        'то происходит FATAL_ERROR(1) и программа завершает работу.\n\n\n'
        'Файл назначения \'filename.bf.c\' будет перезаписан, если он существует.\n\n\n'
      >
    >
}

/*

<Interpretator e.Tokenize_Code> == s.CurrentCell t.Vector

e.Tokenize_Code ::= e.Token*
e.Token ::= Next | Prev | Inc | Dec | Print | Read | Open s.BracketLevel | Close s.BracketLevel
s.BracketLevel ::= s.NUMBER
s.CurrentCell ::= s.NUMBER
t.Vector ::= ADT.Vector

*/
Interpretator {
  e.Tokenize_Code = <DoInterpretator e.Tokenize_Code 0 <VectorNew (0)>>
}

/*

<DoInterpretator e.Tokenize_Code s.CurrentCell t.Vector> == s.NewCurrentCell t.NewVector

e.Tokenize_Code ::= e.Token*
e.Token ::= Next | Prev | Inc | Dec | Print | Read | Open s.BracketLevel | Close s.BracketLevel
s.BracketLevel ::= s.NUMBER
s.CurrentCell, s.NewCurrentCell ::= s.NUMBER
t.Vector, t.NewVector ::= ADT.Vector

*/
DoInterpretator {
  /* empty */ s.CurrentCell t.Vector = s.CurrentCell t.Vector;
  Next e.Rest_Tokenize_Code s.CurrentCell t.Vector,
  <Compare <Inc s.CurrentCell> <VectorLength t.Vector>>:'0' = 
    <DoInterpretator e.Rest_Tokenize_Code <Inc s.CurrentCell> <VectorPushLast t.Vector 0>>;
  Next e.Rest_Tokenize_Code s.CurrentCell t.Vector = 
    <DoInterpretator e.Rest_Tokenize_Code <Inc s.CurrentCell> t.Vector>;
  Prev e.Rest_Tokenize_Code s.CurrentCell t.Vector,
  s.CurrentCell:0 = 
    <DoInterpretator e.Rest_Tokenize_Code s.CurrentCell <VectorPushFirst t.Vector 0>>;
  Prev e.Rest_Tokenize_Code s.CurrentCell t.Vector = 
    <DoInterpretator e.Rest_Tokenize_Code <Dec s.CurrentCell> t.Vector>;
  Inc e.Rest_Tokenize_Code s.CurrentCell t.Vector,
  <VectorGet t.Vector s.CurrentCell>:255 =
    <DoInterpretator e.Rest_Tokenize_Code s.CurrentCell <VectorSet t.Vector s.CurrentCell 0>>; 
  Inc e.Rest_Tokenize_Code s.CurrentCell t.Vector =
    <DoInterpretator e.Rest_Tokenize_Code s.CurrentCell <VectorSet t.Vector s.CurrentCell <Inc <VectorGet t.Vector s.CurrentCell>>>>; 							
  Dec e.Rest_Tokenize_Code s.CurrentCell t.Vector,
  <VectorGet t.Vector s.CurrentCell>:0 =
    <DoInterpretator e.Rest_Tokenize_Code s.CurrentCell <VectorSet t.Vector s.CurrentCell 255>>; 
  Dec e.Rest_Tokenize_Code s.CurrentCell t.Vector =
    <DoInterpretator e.Rest_Tokenize_Code s.CurrentCell <VectorSet t.Vector s.CurrentCell <Dec <VectorGet t.Vector s.CurrentCell>>>>; 
  Print e.Rest_Tokenize_Code s.CurrentCell t.Vector =
    <Putchar <Chr <VectorGet t.Vector s.CurrentCell>>> 
    <DoInterpretator e.Rest_Tokenize_Code s.CurrentCell t.Vector>;														
  Read e.Rest_Tokenize_Code s.CurrentCell t.Vector =
    <DoInterpretator e.Rest_Tokenize_Code s.CurrentCell <VectorSet t.Vector s.CurrentCell <Ord <Getchar>>>>;							
  Open s.BracketLevel e.OpenClose Close s.BracketLevel e.Rest_Tokenize_Code s.CurrentCell t.Vector,
  <VectorGet t.Vector s.CurrentCell>:0 =
    <DoInterpretator e.Rest_Tokenize_Code s.CurrentCell t.Vector>;
  Open s.BracketLevel e.OpenClose Close s.BracketLevel e.Rest_Tokenize_Code s.CurrentCell t.Vector =
    <DoInterpretator Open s.BracketLevel e.OpenClose Close s.BracketLevel e.Rest_Tokenize_Code <DoInterpretator e.OpenClose>>   
}

/*

<CompiletoC e.Tokenize_Code> == t.C_Code

e.Tokenize_Code ::= e.Token*
e.Token ::= Next | Prev | Inc | Dec | Print | Read | Open s.BracketLevel | Close s.BracketLevel
s.BracketLevel ::= s.NUMBER
t.C_Code ::= (CHAR+)

*/
CompiletoC {
  e.Tokenize_Code =
    (
      '#include <memory.h>\n'
      '#include <stdio.h>\n\n'
      'int main(void)\n'
      '{\n'
      '     int i = 0;\n'
      '     unsigned char arr[30000];\n'
  	  '     memset(arr, 0, sizeof(arr));\n'
      <DoCompiletoC ('     ') e.Tokenize_Code>
      '}'
	)	
}

DoCompiletoC {
  (e.Spaces) /* empty */ = /* empty */;
  (e.Spaces) Next e.Rest_Tokenize_Code =
    e.Spaces 'i++;\n' <DoCompiletoC (e.Spaces) e.Rest_Tokenize_Code>;
  (e.Spaces) Prev e.Rest_Tokenize_Code =
    e.Spaces 'i--;\n' <DoCompiletoC (e.Spaces) e.Rest_Tokenize_Code>;
  (e.Spaces) Inc e.Rest_Tokenize_Code =
    e.Spaces 'arr[i]++;\n' <DoCompiletoC (e.Spaces) e.Rest_Tokenize_Code>;
  (e.Spaces) Dec e.Rest_Tokenize_Code =
    e.Spaces 'arr[i]--;\n' <DoCompiletoC (e.Spaces) e.Rest_Tokenize_Code>;
  (e.Spaces) Print e.Rest_Tokenize_Code =
    e.Spaces 'putchar(arr[i]);\n' <DoCompiletoC (e.Spaces) e.Rest_Tokenize_Code>;
  (e.Spaces) Read e.Rest_Tokenize_Code =
    e.Spaces 'arr[i] = getchar();\n' <DoCompiletoC (e.Spaces) e.Rest_Tokenize_Code>;
  (e.Spaces) Open s.BracketLevel e.OpenClose Close s.BracketLevel e.Rest_Tokenize_Code =
    e.Spaces 'while(arr[i])\n' 
    e.Spaces '{\n' 
    <DoCompiletoC (e.Spaces '     ') e.OpenClose>
    e.Spaces '}\n' 
    <DoCompiletoC (e.Spaces) e.Rest_Tokenize_Code>
}

/* 

<Tokenizer e.Symbols> == e.Tokenize_Code | e.Errors

e.Symbols ::= (s.Char s.Row s.Col)* 
s.Char ::= s.CHAR
s.Row, s.Col ::= s.NUMBER
e.Tokenize_Code ::= e.Token*
e.Token ::= Next | Prev | Inc | Dec | Print | Read | Open s.BracketLevel | Close s.BracketLevel
s.BracketLevel ::= s.NUMBER
e.Errors ::= Fails (e.ErrorMessage)+
e.ErrorMessage ::= s.CHAR+

*/
Tokenizer {
  e.Symbols, <BracketsCheck e.Symbols>: Fails e.Errors = Fails e.Errors;
  e.Symbols =
    <DelAccumulator
      <MapAccum 
        {
          s.BracketLevel (s.Char e.RowCol), s.Char:'[' =
            <Inc s.BracketLevel> Open  <Inc s.BracketLevel>;
          s.BracketLevel (s.Char e.RowCol), s.Char:']' =
            <Dec s.BracketLevel> Close  s.BracketLevel; 
          s.BracketLevel (s.Char e.RowCol), s.Char:'>' = 
            s.BracketLevel Next; 
          s.BracketLevel (s.Char e.RowCol), s.Char:'<' =
            s.BracketLevel Prev; 
          s.BracketLevel (s.Char e.RowCol), s.Char:'+' =
            s.BracketLevel Inc; 
          s.BracketLevel (s.Char e.RowCol), s.Char:'-' =
            s.BracketLevel Dec;
          s.BracketLevel (s.Char e.RowCol), s.Char:'.' =
            s.BracketLevel Print;
          s.BracketLevel (s.Char e.RowCol), s.Char:',' =
            s.BracketLevel Read;
          s.BracketLevel (s.Char e.RowCol) =
            s.BracketLevel /* empty */
        } 
        0 e.Symbols
      >
    >
}

/*

<BracketsCheck e.Symbols> == Success | e.Errors

e.Symbols ::= (s.Char s.Row s.Col)* 
s.Char ::= s.CHAR
s.Row, s.Col  ::= s.NUMBER
e.Errors ::= Fails (e.ErrorMessage)+
e.ErrorMessage ::= s.CHAR+

*/
BracketsCheck {
  e.Symbols =
    <Reduce
      {
        t.Vector ('[' s.Row s.Col) =
          <VectorPushLast t.Vector <RU 'SYNTAX_ERROR(12): Отсутствует символ \']\' для символа \'[\' на строке: '> s.Row <RU ', столбце: '> s.Col '.'>;
        t.Vector (']' s.Row s.Col), <VectorLength t.Vector>:0 =
          <VectorPushLast t.Vector <RU 'SYNTAX_ERROR(11): Непредвиденный символ \']\' на строке: '> s.Row <RU ', столбце: '> s.Col '.'>;
        t.Vector (']' s.Row s.Col) = <VectorPopLast t.Vector>;        
        t.Vector (e.CharRowCol) = t.Vector
      }
      <VectorNew> e.Symbols
    >:
    {
      t.Vector, <VectorLength t.Vector>:0 = Success;
      t.Vector = Fails <VectorGetAll t.Vector>
    }
}
	
$ENTRY Go {
  =
    /* Аргумент программы - имя файла, где находится код Brainfuck.*/
    <Arg 1>: 
    /* По умолчанию имя файла - 'brainfuck.bf'. Можно в конце имени файла не добавлять расширение .bf */				
    { 
      /* empty */ = 'brainfuck.bf';
      e.FileName '.bf' = e.FileName '.bf';
      e.FileName = e.FileName '.bf'
    }:
    e.bfFileName =
    <Help>
    <Prout <RU 'Код на языке Brainfuck из исходного файла '> e.bfFileName ':\n'>
    <Fetch
      e.bfFileName			
      <Pipe 
        /* Если файл не существует, то выход из программы. */
        ExistFile
        {
          True = e.bfFileName;
          False = <Prout <RU 'FATAL_ERROR (1): Файл '> e.bfFileName <RU ' не существует.'>> <Exit 1>
        }
        /* Загрузка строк файла в e.Lines ::= (e.Line)*;  e.Line ::= s.CHAR* */
        LoadFile
        /* Вывод строк файла на консоль и преобразование строк e.Lines => e.Symbols
        e.Symbols ::= (s.Char s.Row s.Col)*; s.Char ::= s.CHAR; s.Row ::= s.NUMBER; s.Col  ::= s.NUMBER */
        (
          MapAccum 
            {
              s.Row (e.Line) =
                <Inc s.Row> 
				<Prout s.Row ' ' e.Line>
                <Fetch
                  e.Line
                  <Pipe
                    (MapAccum {s.Col s.Char = <Inc s.Col> (s.Char s.Row s.Col)} 1)
                    DelAccumulator
                  >
                >	
            }
            1
        )
        DelAccumulator
        /* Запуск лексического (синтаксического) анализатора */
        &Tokenizer
        {
          /* Если Fails, то завершение программы */
          Fails e.Errors =	
            <Map {e.ErrorMessage = <Prout e.ErrorMessage>} e.Errors> 
            <Prout <RU 'FATAL_ERROR (99): Существуют несколько синтаксических ошибок.'>>
            <Exit 99>;
          e.Tokenize_Code = 
            <Fetch
              e.Tokenize_Code
              <Pipe 
                /* Запуск компилятора в код C */
                &CompiletoC
                /* Сохранение кода C в файл */
                (SaveFile (e.bfFileName '.c'))
                /* Запуск интерпретатора */
                Prout
                (&Interpretator e.Tokenize_Code)
              >
            >
        }
      >
    >
}
