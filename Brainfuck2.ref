* Copyright 2023 Aleksandr Bocharov
* Distributed under the Boost Software License, Version 1.0.
* See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt
* 2023-05-25

/* 

Brainfuck 2

Программа "Brainfuck 2" написана на языке программирования Рефал-5-Лямбда.
https://github.com/bmstu-iu9/refal-5-lambda

Программа "Brainfuck 2" интерпретирует код на языке Brainfuck из исходного файла 'filename.bf'
и компилирует его в код на языке C в файл назначения 'filename.bf.c'.


ИСПОЛЬЗОВАНИЕ:
    brainfuck2 [filename[.bf]]


где
    filename        Имя исходного файла и файла назначения.


Имя по умолчанию исходного файла 'brainfuck.bf'
и файла назначения 'brainfuck.bf.c'.


Если исходный файл 'filename.bf' не существует,
то происходит FATAL_ERROR(1) и программа завершает работу.


Файл назначения 'filename.bf.c' будет перезаписан, если он существует.



*/

*$FROM LibraryEx
$EXTERN Fetch, Pipe, Map, MapAccum, DelAccumulator, LoadFile, SaveFile, Inc, Dec;

*$FROM stdio
$EXTERN Putchar, Getchar, RU;

*$FROM Vector
$EXTERN VectorNew, VectorSet, VectorGet, VectorPushFirst,
VectorPushLast, VectorPopLast, VectorLength, VectorGetAll;


* Вывод справки
Help {
  = <Prout
      <RU
        '\nПрограмма "Brainfuck 2" интерпретирует код на языке Brainfuck из исходного файла \'filename.bf\'\n'
        'и компилирует его в код на языке C в файл назначения \'filename.bf.c\'.\n\n\n'
        'ИСПОЛЬЗОВАНИЕ:\n'
        '    brainfuck2 [filename[.bf]]\n\n\n'
        'где\n'
        '    filename        Имя исходного файла и файла назначения.\n\n\n'
        'Имя по умолчанию исходного файла \'brainfuck.bf\'\n'
        'и файла назначения \'brainfuck.bf.c\'.\n\n\n'
        'Если исходный файл \'filename.bf\' не существует,\n'
        'то происходит FATAL_ERROR(1) и программа завершает работу.\n\n\n'
        'Файл назначения \'filename.bf.c\' будет перезаписан, если он существует.\n\n\n'
      >
    >
}

/*

<Interpretator e.Parsing_Tree> == s.CurrentCell t.Vector

e.Parsing_Tree ::= e.Token*
e.Token ::= Next | Prev | Inc | Dec | Print | Read | Open s.BracketLevel | Close s.BracketLevel
s.BracketLevel ::= s.NUMBER
s.CurrentCell ::= s.NUMBER
t.Vector ::= ADT.Vector

*/
Interpretator {
  e.Parsing_Tree =
    <DoInterpretator e.Parsing_Tree 0 <VectorNew (0)>>
}

/*

<DoInterpretator e.Parsing_Tree s.CurrentCell t.Vector> == s.NewCurrentCell t.NewVector

e.Parsing_Tree ::= e.Token*
e.Token ::= Next | Prev | Inc | Dec | Print | Read | Open s.BracketLevel | Close s.BracketLevel
s.BracketLevel ::= s.NUMBER
s.CurrentCell, s.NewCurrentCell ::= s.NUMBER
t.Vector, t.NewVector ::= ADT.Vector

*/
DoInterpretator {
  /* empty */ s.CurrentCell t.Vector =
    s.CurrentCell t.Vector;
  Next e.Rest_Parsing_Tree s.CurrentCell t.Vector,
  <Compare <Inc s.CurrentCell> <VectorLength t.Vector>>:'0' = 
    <DoInterpretator e.Rest_Parsing_Tree <Inc s.CurrentCell> <VectorPushLast t.Vector 0>>;
  Next e.Rest_Parsing_Tree s.CurrentCell t.Vector = 
    <DoInterpretator e.Rest_Parsing_Tree <Inc s.CurrentCell> t.Vector>;
  Prev e.Rest_Parsing_Tree s.CurrentCell t.Vector,
  s.CurrentCell:0 = 
    <DoInterpretator e.Rest_Parsing_Tree s.CurrentCell <VectorPushFirst t.Vector 0>>;
  Prev e.Rest_Parsing_Tree s.CurrentCell t.Vector = 
    <DoInterpretator e.Rest_Parsing_Tree <Dec s.CurrentCell> t.Vector>;
  Inc e.Rest_Parsing_Tree s.CurrentCell t.Vector,
  <VectorGet t.Vector s.CurrentCell>:255 =
    <DoInterpretator e.Rest_Parsing_Tree s.CurrentCell <VectorSet t.Vector s.CurrentCell 0>>; 
  Inc e.Rest_Parsing_Tree s.CurrentCell t.Vector =
    <DoInterpretator e.Rest_Parsing_Tree s.CurrentCell <VectorSet t.Vector s.CurrentCell <Inc <VectorGet t.Vector s.CurrentCell>>>>; 							
  Dec e.Rest_Parsing_Tree s.CurrentCell t.Vector,
  <VectorGet t.Vector s.CurrentCell>:0 =
    <DoInterpretator e.Rest_Parsing_Tree s.CurrentCell <VectorSet t.Vector s.CurrentCell 255>>; 
  Dec e.Rest_Parsing_Tree s.CurrentCell t.Vector =
    <DoInterpretator e.Rest_Parsing_Tree s.CurrentCell <VectorSet t.Vector s.CurrentCell <Dec <VectorGet t.Vector s.CurrentCell>>>>; 
  Print e.Rest_Parsing_Tree s.CurrentCell t.Vector =
    <Putchar <Chr <VectorGet t.Vector s.CurrentCell>>> 
    <DoInterpretator e.Rest_Parsing_Tree s.CurrentCell t.Vector>;														
  Read e.Rest_Parsing_Tree s.CurrentCell t.Vector =
    <DoInterpretator e.Rest_Parsing_Tree s.CurrentCell <VectorSet t.Vector s.CurrentCell <Ord <Getchar>>>>;							
  Open s.BracketLevel e.OpenClose Close s.BracketLevel e.Rest_Parsing_Tree s.CurrentCell t.Vector,
  <VectorGet t.Vector s.CurrentCell>:0 =
    <DoInterpretator e.Rest_Parsing_Tree s.CurrentCell t.Vector>;
  Open s.BracketLevel e.OpenClose Close s.BracketLevel e.Rest_Parsing_Tree s.CurrentCell t.Vector =
    <DoInterpretator Open s.BracketLevel e.OpenClose Close s.BracketLevel e.Rest_Parsing_Tree <DoInterpretator e.OpenClose s.CurrentCell t.Vector>>   
}

/*

<CompiletoC e.Parsing_Tree> == t.C_Code

e.Parsing_Tree ::= e.Token*
e.Token ::= Next | Prev | Inc | Dec | Print | Read | Open s.BracketLevel | Close s.BracketLevel
s.BracketLevel ::= s.NUMBER
t.C_Code ::= (s.CHAR+)

*/
CompiletoC {
  e.Parsing_Tree =
    (
      '#include <memory.h>\n'
      '#include <stdio.h>\n\n'
      'int main(void)\n'
      '{\n'
      '     int i = 0;\n'
      '     unsigned char arr[30000];\n'
      '     memset(arr, 0, sizeof(arr));\n'
      <DoCompiletoC ('     ') e.Parsing_Tree>
      '}'
    )	
}

DoCompiletoC {
  (e.Spaces) /* empty */ =
    /* empty */;
  (e.Spaces) Next e.Rest_Parsing_Tree =
    e.Spaces 'i++;\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Prev e.Rest_Parsing_Tree =
    e.Spaces 'i--;\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Inc e.Rest_Parsing_Tree =
    e.Spaces 'arr[i]++;\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Dec e.Rest_Parsing_Tree =
    e.Spaces 'arr[i]--;\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Print e.Rest_Parsing_Tree =
    e.Spaces 'putchar(arr[i]);\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Read e.Rest_Parsing_Tree =
    e.Spaces 'arr[i] = getchar();\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Open s.BracketLevel e.OpenClose Close s.BracketLevel e.Rest_Parsing_Tree =
    e.Spaces 'while(arr[i])\n' 
    e.Spaces '{\n' 
    <DoCompiletoC (e.Spaces '     ') e.OpenClose>
    e.Spaces '}\n' 
    <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>
}

/* 

<Parser e.Symbols> == e.Parsing_Tree | Fails e.Errors

e.Symbols ::= (s.Char s.Row s.Col)* 
s.Char ::= s.CHAR
s.Row, s.Col ::= s.NUMBER
e.Parsing_Tree ::= e.Token*
e.Token ::= Next | Prev | Inc | Dec | Print | Read | Open s.BracketLevel | Close s.BracketLevel
s.BracketLevel ::= s.NUMBER
e.Errors ::= (e.ErrorMessage)+
e.ErrorMessage ::= s.CHAR+

*/
Parser {
  e.Symbols =
    <MapAccum 
      {
        (t.Vector11 t.Vector12 s.BracketLevel) ('[' s.Row s.Col) =
          (
            t.Vector11
            <VectorPushLast t.Vector12 <RU 'SYNTAX_ERROR(12): Отсутствует символ \']\' для символа \'[\' на строке: '> s.Row <RU ', столбце: '> s.Col '.'>
            <Inc s.BracketLevel>
          )
          Open  <Inc s.BracketLevel>;
        (t.Vector11 t.Vector12 s.BracketLevel) (']' s.Row s.Col),
        <VectorLength t.Vector12>:0 =
          (
            <VectorPushLast t.Vector11 <RU 'SYNTAX_ERROR(11): Непредвиденный символ \']\' на строке: '> s.Row <RU ', столбце: '> s.Col '.'>
            t.Vector12
            s.BracketLevel
          )
          /* empty */; 
        (t.Vector11 t.Vector12 s.BracketLevel) (']' s.Row s.Col) =
          (
            t.Vector11
            <VectorPopLast t.Vector12>
            <Dec s.BracketLevel>
          )
          Close  s.BracketLevel;   
        (t.Vector11 t.Vector12 s.BracketLevel) ('>' e._) = 
          (t.Vector11 t.Vector12 s.BracketLevel)
          Next; 
        (t.Vector11 t.Vector12 s.BracketLevel) ('<' e._) =
          (t.Vector11 t.Vector12 s.BracketLevel)
          Prev; 
        (t.Vector11 t.Vector12 s.BracketLevel) ('+' e._) =
          (t.Vector11 t.Vector12 s.BracketLevel)
          Inc; 
        (t.Vector11 t.Vector12 s.BracketLevel) ('-' e._) =
          (t.Vector11 t.Vector12 s.BracketLevel)
          Dec;
        (t.Vector11 t.Vector12 s.BracketLevel) ('.' e._) =
          (t.Vector11 t.Vector12 s.BracketLevel)
          Print;
        (t.Vector11 t.Vector12 s.BracketLevel) (',' e._) =
          (t.Vector11 t.Vector12 s.BracketLevel)
          Read;
        (t.Vector11 t.Vector12 s.BracketLevel) (s._ e._) =
          (t.Vector11 t.Vector12 s.BracketLevel)
          /* empty */
      } 
      (<VectorNew> <VectorNew> 0)
      e.Symbols
    >:
    {
      (t.Vector11 t.Vector12 s._) e.Parsing_Tree,
      <VectorLength t.Vector11>:0, <VectorLength t.Vector12>:0 =
        e.Parsing_Tree;
      (t.Vector11 t.Vector12 s._) e._ =
        Fails <VectorGetAll t.Vector11> <VectorGetAll t.Vector12>
    }
}
	
$ENTRY Go {
  =
    /* Аргумент программы - имя файла, где находится код Brainfuck.*/
    <Arg 1>: 
    /* По умолчанию имя файла - 'brainfuck.bf'. Можно в конце имени файла не добавлять расширение .bf */				
    { 
      /* empty */ =
        'brainfuck.bf';
      e.FileName '.bf' =
        e.FileName '.bf';
      e.FileName =
        e.FileName '.bf'
    }:
    e.bfFileName =
    <Help>
    <Prout <RU 'Код на языке Brainfuck из исходного файла '> e.bfFileName ':\n'>
    <Fetch
      e.bfFileName			
      <Pipe 
        /* Если файл не существует, то выход из программы. */
        ExistFile
        {
          True =
            e.bfFileName;
          False =
            <Prout <RU 'FATAL_ERROR (1): Файл '> e.bfFileName <RU ' не существует.'>>
            <Exit 1>
        }
        /* Загрузка строк файла в e.Lines ::= (e.Line)*;  e.Line ::= s.CHAR* */
        LoadFile
        /* Вывод строк файла на консоль и преобразование строк e.Lines => e.Symbols
        e.Symbols ::= (s.Char s.Row s.Col)*; s.Char ::= s.CHAR; s.Row ::= s.NUMBER; s.Col  ::= s.NUMBER */
        (
          MapAccum 
            {
              s.Row (e.Line) =
                <Inc s.Row> 
                <Prout s.Row ' ' e.Line>
                <Fetch
                  e.Line
                  <Pipe
                    (MapAccum {s.Col s.Char = <Inc s.Col> (s.Char s.Row s.Col)} 1)
                    DelAccumulator
                  >
                >	
            }
            1
        )
        DelAccumulator
        /* Запуск лексического и синтаксического анализатора */
        &Parser
        {
          /* Если Fails, то завершение программы */
          Fails e.Errors =	
            <Map {(e.ErrorMessage) = <Prout e.ErrorMessage>} e.Errors> 
            <Prout <RU 'FATAL_ERROR (99): Существуют несколько синтаксических ошибок.'>>
            <Exit 99>;
          e.Parsing_Tree = 
            <Fetch
              e.Parsing_Tree
              <Pipe 
                /* Запуск компилятора в код C */
                &CompiletoC
                /* Сохранение кода C в файл */
                (SaveFile (e.bfFileName '.c'))
                /* Запуск интерпретатора */
                Prout
                (&Interpretator e.Parsing_Tree)
              >
            >
        }
      >
    >
}
