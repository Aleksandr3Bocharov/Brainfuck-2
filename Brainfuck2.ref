* Copyright 2023 Aleksandr Bocharov
* Distributed under the Boost Software License, Version 1.0.
* See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt
* 2023-07-18
* https://github.com/Aleksandr3Bocharov/Brainfuck-2

/* 

Brainfuck 2

Программа "Brainfuck 2" написана на языке программирования Рефал-05.
https://github.com/Mazdaywik/Refal-05

Программа "Brainfuck 2" использует библиотеку GTK3.
https://docs.gtk.org/gtk3/

Программа "Brainfuck 2" интерпретирует код на языке Brainfuck из исходного файла
и компилирует его в код на языке C в файл назначения.

*/

*$FROM LibraryEx
$EXTERN Map, MapAccum, DelAccumulator, LoadFile, SaveFile, Inc, Dec;

*$FROM Platform
$EXTERN Platform;

*$FROM libraryc
$EXTERN PutChar, GetChar, OpenFileDialog, SaveFileDialog;

* Вывод справки
Help {
  = <Prout
      '\nПрограмма "Brainfuck 2" интерпретирует код на языке Brainfuck из исходного файла\n'
      'и компилирует его в код на языке C в файл назначения.\n\n\n'
    >
}

/*

<Interpretator e.Parsing_Tree> == 

e.Parsing_Tree ::= t.LeafNode*
t.LeafNode ::= s.Leaf | (t.LeafNode*)
s.Leaf ::= Next | Prev | Inc | Dec | Write | Read

*/
Interpretator {
  e.Parsing_Tree,
  <DoInterpretator e.Parsing_Tree () 0 ()>: e.Cells =
}

DoInterpretator {
  (e.BeforeCells) s.Cell (e.AfterCells) =
    (e.BeforeCells) s.Cell (e.AfterCells);
  Next e.Rest_Parsing_Tree (e.BeforeCells) s.Cell () =
    <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells s.Cell) 0 ()>;
  Next e.Rest_Parsing_Tree (e.BeforeCells) s.Cell (s.NextCell e.AfterCells) =
    <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells s.Cell) s.NextCell (e.AfterCells)>;    
  Prev e.Rest_Parsing_Tree () s.Cell (e.AfterCells) =
    <DoInterpretator e.Rest_Parsing_Tree () 0 (s.Cell e.AfterCells)>;
  Prev e.Rest_Parsing_Tree (e.BeforeCells s.PrevCell) s.Cell (e.AfterCells) =
    <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) s.PrevCell (s.Cell e.AfterCells)>;    
  Inc e.Rest_Parsing_Tree (e.BeforeCells) 255 (e.AfterCells) =
    <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) 0 (e.AfterCells)>;
  Inc e.Rest_Parsing_Tree (e.BeforeCells) s.Cell (e.AfterCells) =
    <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) <Inc s.Cell> (e.AfterCells)>;     							
  Dec e.Rest_Parsing_Tree (e.BeforeCells) 0 (e.AfterCells) =
    <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) 255 (e.AfterCells)>;
  Dec e.Rest_Parsing_Tree (e.BeforeCells) s.Cell (e.AfterCells) =
    <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) <Dec s.Cell> (e.AfterCells)>;    
  Write e.Rest_Parsing_Tree (e.BeforeCells) s.Cell (e.AfterCells) =
    <PutChar <Chr s.Cell>> 
    <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) s.Cell (e.AfterCells)>;												
  Read e.Rest_Parsing_Tree (e.BeforeCells) s.Cell (e.AfterCells) =
    <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) <Ord <GetChar>> (e.AfterCells)>;						
  (e.LeafNode) e.Rest_Parsing_Tree (e.BeforeCells) 0 (e.AfterCells) =
    <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) 0 (e.AfterCells)>;
  (e.LeafNode) e.Rest_Parsing_Tree (e.BeforeCells) s.Cell (e.AfterCells),
  <DoInterpretator e.LeafNode (e.BeforeCells) s.Cell (e.AfterCells)>: e.Cells =
    <DoInterpretator (e.LeafNode) e.Rest_Parsing_Tree e.Cells>   
}

/*

<CompiletoC e.Parsing_Tree> == t.C_Code

e.Parsing_Tree ::= t.LeafNode*
t.LeafNode ::= s.Leaf | (t.LeafNode*)
s.Leaf ::= Next | Prev | Inc | Dec | Write | Read
t.C_Code ::= (s.CHAR+)

*/
CompiletoC {
  e.Parsing_Tree =
    (
      '#include <memory.h>\n'
      '#include <stdio.h>\n\n'
      'int main(void)\n'
      '{\n'
      '     int i = 0;\n'
      '     unsigned char arr[30000];\n'
      '     memset(arr, 0, sizeof(arr));\n'
      <DoCompiletoC ('     ') e.Parsing_Tree>
      '     return 0;\n'
      '}'
    )	
}

DoCompiletoC {
  (e.Spaces) =
    ;
  (e.Spaces) Next e.Rest_Parsing_Tree =
    e.Spaces 'i++;\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Prev e.Rest_Parsing_Tree =
    e.Spaces 'i--;\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Inc e.Rest_Parsing_Tree =
    e.Spaces 'arr[i]++;\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Dec e.Rest_Parsing_Tree =
    e.Spaces 'arr[i]--;\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Write e.Rest_Parsing_Tree =
    e.Spaces 'putchar(arr[i]);\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) Read e.Rest_Parsing_Tree =
    e.Spaces 'arr[i] = getchar();\n' <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>;
  (e.Spaces) (e.LeafNode) e.Rest_Parsing_Tree =
    e.Spaces 'while(arr[i])\n' 
    e.Spaces '{\n' 
    <DoCompiletoC (e.Spaces '     ') e.LeafNode>
    e.Spaces '}\n' 
    <DoCompiletoC (e.Spaces) e.Rest_Parsing_Tree>
}

/* 

<Parser e.Tokens> == e.Parsing_Tree

e.Tokens ::= s.Token*
s.Token ::= '>' | '<' | '+' | '-' | '.' | ',' | '[' | ']' 
e.Parsing_Tree ::= t.LeafNode*
t.LeafNode ::= s.Leaf | (t.LeafNode*)
s.Leaf ::= Next | Prev | Inc | Dec | Write | Read

*/
Parser {
  =
    ;
  '>' e.RestTokens =
    Next <Parser e.RestTokens>;
  '<' e.RestTokens =
    Prev <Parser e.RestTokens>;
  '+' e.RestTokens =
    Inc <Parser e.RestTokens>;    
  '-' e.RestTokens =
    Dec <Parser e.RestTokens>; 
  '.' e.RestTokens =
    Write <Parser e.RestTokens>;
  ',' e.RestTokens =
    Read <Parser e.RestTokens>;
  '[' e.RestTokens,
  <Parser e.RestTokens>: e.LeafNode (e.NewRestTokens) =
    (e.LeafNode) <Parser e.NewRestTokens>;
  ']' e.RestTokens =
    (e.RestTokens)      
}

/* 

<Tokenizer e.Symbols> == e.Tokens | Fails e.Errors

e.Symbols ::= (s.Char s.Row s.Col)* 
s.Char ::= s.CHAR
s.Row, s.Col ::= s.NUMBER
e.Tokens ::= s.Token*
s.Token ::= '>' | '<' | '+' | '-' | '.' | ',' | '[' | ']' 
e.Errors ::= (e.ErrorMessage)+
e.ErrorMessage ::= s.CHAR+

*/
Tokenizer {
  e.Symbols,
  <Br Fails11 '=' >
  <Br Fails12 '=' >
  <Map DoMapTokenizer e.Symbols>:
  {
    e.Tokens,
    <Cp Fails11>: ,
    <Cp Fails12>: =
      e.Tokens
      <Rp Fails11 '=' >
      <Rp Fails12 '=' >
      <Dg Fails11>
      <Dg Fails12>;
    e.Tokens =
      Fails
      <Cp Fails11>
      <Cp Fails12>
      <Rp Fails11 '=' >
      <Rp Fails12 '=' >
      <Dg Fails11>
      <Dg Fails12>
  }
}

DoMapTokenizer {
  ('[' s.Row s.Col) =
    <Rp Fails12 '=' <Cp Fails12> ('SYNTAX_ERROR(12): Отсутствует символ \']\' для символа \'[\' в строке: ' s.Row ' и столбце: ' s.Col '.')>
    '[';
  (']' s.Row s.Col),
  <Cp Fails12>: =
    <Rp Fails11 '=' <Cp Fails11> ('SYNTAX_ERROR(11): Непредвиденный символ \']\' в строке: ' s.Row ' и столбце: ' s.Col '.')>
      ; 
  (']' s.Row s.Col),
  <Cp Fails12>: e.Fails12 (e.Fail12) =
    <Rp Fails12 '=' e.Fails12>
    ']';   
  ('>' s.Row s.Col) = 
    '>'; 
  ('<' s.Row s.Col) =
    '<'; 
  ('+' s.Row s.Col) =
    '+'; 
  ('-' s.Row s.Col) =
    '-';
  ('.' s.Row s.Col) =
    '.';
  (',' s.Row s.Col) =
    ',';
  (s.Char s.Row s.Col) =
}
	
DoMapPrintErrors {
  (e.ErrorMessage) =
    <Prout e.ErrorMessage>
}

DoMapPrint {
  s.Row (e.Line) =
    <Inc s.Row> 
    <Prout s.Row ' ' e.Line>
    <DelAccumulator <MapAccum DoMapPrint-Aux (s.Row 1) e.Line>>	
}

DoMapPrint-Aux {
  (s.Row s.Col) s.Char =
    (s.Row <Inc s.Col>)
    (s.Char s.Row s.Col)
}

/*

<bfFileName e.bfFileName> == e.bfFileName

e.bfFileName ::= s.CHAR*

*/
bfFileName {
  =
    <Prout 'FATAL_ERROR (1): Файл с кодом на языке Brainfuck не выбран.'>
    <Exit 1>;
  e.bfFileName =
    e.bfFileName
}

/*

<cFileName e.cFileName t.C_Code> ==

e.cFileName ::= s.CHAR*
t.C_Code ::= (s.CHAR+)

*/
cFileName {
  t.C_Code =
    <Prout 'ERROR (14): Файл с кодом на языке C не сохранён.\n'>;
  e.cFileName t.C_Code =
    <SaveFile (e.cFileName) t.C_Code>
    <Prout 'Файл с кодом на языке C ' e.cFileName ' сохранён.\n'>
}

/*

<CHCP s.Platform> == 

s.Platform ::= Windows | POSIX

*/
CHCP {
  Windows,
  <System 'chcp 65001'>: e.RetCode =
    ;
  POSIX =
}

$ENTRY Go {
  ,
  <CHCP <Platform>>
  <Help>
  <Prout 'Открытие файла с кодом на языке Brainfuck.\n'>
  <bfFileName <OpenFileDialog>>: e.bfFileName,
  <Prout 'Код на языке Brainfuck из исходного файла ' e.bfFileName ':\n'>
  /* Загрузка строк файла в e.Lines ::= (e.Line)*;  e.Line ::= s.CHAR* */
  <LoadFile e.bfFileName>: e.Lines,
  /* Вывод строк файла на консоль и преобразование строк e.Lines => e.Symbols
  e.Symbols ::= (s.Char s.Row s.Col)*; s.Char ::= s.CHAR; s.Row ::= s.NUMBER; s.Col  ::= s.NUMBER */
  <DelAccumulator <MapAccum DoMapPrint 1 e.Lines>>: e.Symbols,
  /* Запуск лексического анализатора */
  <Tokenizer e.Symbols>:
  {
    /* Если Fails, то завершение программы */
    Fails e.Errors =	
      <Prout>
      <Map DoMapPrintErrors e.Errors> 
      <Prout 'FATAL_ERROR (99): Существуют несколько синтаксических ошибок.'>
      <Exit 99>;
    e.Tokens,
    /* Запуск синтаксического анализатора */
    <Parser e.Tokens>: e.Parsing_Tree,
    /* Запуск компилятора в код C */
    <CompiletoC e.Parsing_Tree>: t.C_Code =
      <Prout '\nСохранение файла с кодом на языке C.\n'>
      /* Сохранение кода C в файл */
      <cFileName <SaveFileDialog e.bfFileName '.c'> t.C_Code>
      /* Запуск интерпретатора */
      <Prout 'Запуск интерпретатора.\n'>
      <Interpretator e.Parsing_Tree>
  }
}