* Copyright 2023 Aleksandr Bocharov
* Distributed under the Boost Software License, Version 1.0.
* See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt
* 2023-05-23

/*

Модуль "Vector" написан на языке программирования Рефал-5-Лямбда.
https://github.com/bmstu-iu9/refal-5-lambda

Модуль "Vector" реализует абстрактный тип данных Vector -
динамический массив выражений [Vector e.Vector] и функции для работы с ним.

e.Vector ::= (s.Index e.Value)*
s.Index ::= s.NUMBER
e.Value ::= e.ANY-EXPR

*/

*$FROM LibraryEx
$EXTERN Map, MapAccum, DelAccumulator, Inc, Dec;

$ENUM Vector;

/*

<VectorNew e.Source> == [Vector e.Vector]

e.Source ::= (e.Value)*

*/
$ENTRY VectorNew {
  e.Source =
    [Vector <DelAccumulator <MapAccum {s.Ind (e.Val) = <Inc s.Ind> (s.Ind e.Val)} 0 e.Source>>] 
}

/*

<VectorInit s.Length e.Fill> == [Vector e.Vector]

s.Length ::= s.NUMBER
e.Fill= e.ANY-EXPR

*/
$ENTRY VectorInit {
  s.Length e.Fill =
    [Vector <DoVectorInit 0 s.Length e.Fill>] 
}


DoVectorInit {
  s.Length s.Length e._ = /* empty */;
  s.Index s.Length e.Fill =
    (s.Index e.Fill) <DoVectorInit <Inc s.Index> s.Length e.Fill>
}

/*

<VectorGetAll t.Vector> == e.Vector

t.Vector ::= [Vector e.Vector]

*/
$ENTRY VectorGetAll {
  [Vector e.Vector]  = <Map {(s.Ind e.Val) = (e.Val)} e.Vector>    
}

/*

<VectorInsert t.Vector s.Index e.Fill> == [Vector e.NewVector]

t.Vector ::= [Vector e.Vector]
s.Index ::= s.NUMBER
e.Fill ::= e.ANY-EXPR

*/
$ENTRY VectorInsert {
  [Vector /* empty */] 0 e.Fill =
    [Vector (0 e.Fill)];
  [Vector e.Vector-B (s.Index e.Value) e.Vector-E] s.Index e.Fill =
    [Vector e.Vector-B (s.Index e.Fill) (<Inc s.Index> e.Value) <Map {(s.Ind e.Val) = (<Inc s.Ind> e.Val)} e.Vector-E>];
  [Vector e.Vector-B (s.Ind e.Value)] s.Index e.Fill,
  <Compare <Inc s.Ind> s.Index>:'0' =
    [Vector e.Vector-B (s.Ind e.Value) (s.Index e.Fill)]
}

/*

<VectorPushFirst t.Vector e.Fill> == [Vector e.NewVector]

t.Vector ::= [Vector e.Vector]
e.Fill ::= e.ANY-EXPR

*/
$ENTRY VectorPushFirst {
  [Vector /* empty */] e.Fill =
    [Vector (0 e.Fill)];
  [Vector (0 e.Value) e.Vector-E] e.Fill =
    [Vector (0 e.Fill) (1 e.Value) <Map {(s.Ind e.Val) = (<Inc s.Ind> e.Val)} e.Vector-E>]
}


/*

<VectorPushLast t.Vector e.Fill> == [Vector e.NewVector]

t.Vector ::= [Vector e.Vector]
e.Fill ::= e.ANY-EXPR

*/
$ENTRY VectorPushLast {
  [Vector /* empty */] e.Fill =
    [Vector (0 e.Fill)];
  [Vector e.Vector-B (s.Index e.Value)] e.Fill =
    [Vector e.Vector-B (s.Index e.Value) (<Inc s.Index> e.Fill)]
}

/*

<VectorRemove t.Vector s.Index> == [Vector e.NewVector]

t.Vector ::= [Vector e.Vector]
s.Index ::= s.NUMBER

*/
$ENTRY VectorRemove {
  [Vector e.Vector-B (s.Index e._) e.Vector-E] s.Index =
    [Vector e.Vector-B <Map {(s.Ind e.Val) = (<Dec s.Ind> e.Val)} e.Vector-E>]
}

/*

<VectorPopFirst t.Vector> == [Vector e.NewVector]

t.Vector ::= [Vector e.Vector]

*/
$ENTRY VectorPopFirst {
  [Vector (0 e._) e.Vector-E] =
    [Vector <Map {(s.Ind e.Val) = (<Dec s.Ind> e.Val)} e.Vector-E>]
}


/*

<VectorPopLast t.Vector> == [Vector e.NewVector]

t.Vector ::= [Vector e.Vector]

*/
$ENTRY VectorPopLast {
  [Vector e.Vector-B (s._ e._)] =
    [Vector e.Vector-B]
}

/*

<VectorSet t.Vector s.Index e.NewValue> == [Vector e.NewVector]

t.Vector ::= [Vector e.Vector]
s.Index ::= s.NUMBER
e.NewValue ::= e.ANY-EXPR

*/
$ENTRY VectorSet {
  [Vector e.Vector-B (s.Index e._) e.Vector-E] s.Index e.NewValue =
    [Vector e.Vector-B (s.Index e.NewValue) e.Vector-E]
}

/*

<VectorGet t.Vector s.Index> == e.Value

t.Vector ::= [Vector e.Vector]
s.Index ::= s.NUMBER
e.Value ::= e.ANY-EXPR

*/
$ENTRY VectorGet {
  [Vector e.Vector-B (s.Index e.Value) e.Vector-E] s.Index = e.Value
}

/*

<VectorGetFirst t.Vector> == e.Value

t.Vector ::= [Vector e.Vector]
e.Value ::= e.ANY-EXPR

*/
$ENTRY VectorGetFirst {
  [Vector (0 e.Value) e.Vector-E] = e.Value
}

/*

<VectorGetLast t.Vector> == e.Value

t.Vector ::= [Vector e.Vector]
e.Value ::= e.ANY-EXPR

*/
$ENTRY VectorGetLast {
  [Vector e.Vector-B (s.Index e.Value)] = e.Value
}

/*

<VectorLength t.Vector> == s.Length

t.Vector ::= [Vector e.Vector]
s.Length ::= s.NUMBER

*/
$ENTRY VectorLength {
  [Vector /* empty */] = 0;
  [Vector e.Vector-B (s.Index e._)] = <Inc s.Index>
}
