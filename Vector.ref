* Copyright 2023 Aleksandr Bocharov
* Distributed under the Boost Software License, Version 1.0.
* See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt
* 2023-05-21

/*

Модуль "Vector" написан на языке программирования Рефал-5-Лямбда.
https://github.com/bmstu-iu9/refal-5-lambda

Модуль "Vector" реализует абстрактный тип данных Vector -
динамический массив выражений [Vector e.Vector] и функции для работы с ним.

e.Vector ::= (s.Index e.Value)*
s.Index ::= s.NUMBER
e.Value ::= e.ANY-EXPR

*/

*$FROM LibraryEx
$EXTERN Map, MapAccum, DelAccumulator, Inc;

$ENUM Vector;

/*

<VectorNew e.Source> == [Vector e.Vector]

e.Source ::= (e.Value)*

*/
$ENTRY VectorNew {
  e.Source =
    [Vector <DelAccumulator <MapAccum {s.Index (e.Value) = <Inc s.Index> (s.Index e.Value)} 0 e.Source>>] 
}

/*

<VectorInit s.Length e.Fill> == [Vector e.Vector]

s.Length ::= s.NUMBER
e.Fill= e.ANY-EXPR

*/
$ENTRY VectorInit {
  s.Length e.Fill =
    [Vector <DoVectorInit 0 s.Length e.Fill>] 
}


DoVectorInit {
  s.Length s.Length e._ = /* empty */;
  s.Index s.Length e.Fill =
    (s.Index e.Fill) <DoVectorInit <Inc s.Index> s.Length e.Fill>
}

/*

<VectorGetAll t.Vector> == e.Vector

t.Vector ::= [Vector e.Vector]

*/
$ENTRY VectorGetAll {
  [Vector e.Vector]  = <Map {(s.Index e.Value) = (e.Value)} e.Vector>    
}

/*

<VectorInsert t.Vector s.Index e.Fill> == [Vector e.NewVector]

t.Vector ::= [Vector e.Vector]
s.Index ::= s.NUMBER
e.Fill ::= e.ANY-EXPR

*/
$ENTRY VectorInsert {
  [Vector e.Vector] 0 e.Fill =
    [Vector (0 e.Fill) <Map {(s.Ind e.Val) = (<Inc s.Ind> e.Val)} e.Vector>];
  [Vector e.Vector-B (s.Index e.Value) e.Vector-E] s.Index e.Fill =
    [Vector e.Vector-B (s.Index e.Fill) (<Inc s.Index> e.Value) <Map {(s.Ind e.Val) = (<Inc s.Ind> e.Val)} e.Vector-E>];
  [Vector e.Vector] s.Index e.Fill,
  <Length [Vector e.Vector]>:s.Index =
    [Vector e.Vector (s.Index e.Fill)]
}

/*

<VectorRemove t.Vector s.Index> == [Vector e.NewVector]

t.Vector ::= [Vector e.Vector]
s.Index ::= s.NUMBER

*/
$ENTRY VectorRemove {
  [Vector e.Vector-B (s.Index e._) e.Vector-E] s.Index =
    [Vector e.Vector-B <Map {(s.Ind e.Val) = (<Dec s.Ind> e.Val)} e.Vector-E>]
}

/*

<VectorSet t.Vector s.Index e.NewValue> == [Vector e.NewVector]

t.Vector ::= [Vector e.Vector]
s.Index ::= s.NUMBER
e.NewValue ::= e.ANY-EXPR

*/
$ENTRY VectorSet {
  [Vector e.Vector-B (s.Index e._) e.Vector-E] s.Index e.NewValue =
    [Vector e.Vector-B (s.Index e.NewValue) e.Vector-E]
}

/*

<VectorGet t.Vector s.Index> == e.Value

t.Vector ::= [Vector e.Vector]
s.Index ::= s.NUMBER
e.Value ::= e.ANY-EXPR


*/
$ENTRY VectorGet {
  [Vector e.Vector-B (s.Index e.Value) e.Vector-E] s.Index = e.Value
}

/*

<VectorLength t.Vector> == s.Length

t.Vector ::= [Vector e.Vector]
s.Length ::= s.NUMBER

*/
$ENTRY VectorLength {
  [Vector /* empty */] = 0;
  [Vector e.Vector-B (s.Index e._)] = <Inc s.Index>
}
