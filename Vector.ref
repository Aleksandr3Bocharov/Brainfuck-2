* Copyright 2023 Aleksandr Bocharov
* Distributed under the Boost Software License, Version 1.0.
* See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt
* 2023-05-30

/*

Модуль "Vector" написан на языке программирования Рефал-5λ.
https://github.com/bmstu-iu9/refal-5-lambda

Модуль "Vector" реализует абстрактный тип данных Vector -
динамический массив выражений [Vector e.Vector] и функции для работы с ним.

e.Vector ::= (s.Index e.Value)*
s.Index ::= s.NUMBER
e.Value ::= e.ANY-EXPR

*/

*$FROM LibraryEx
$EXTERN Map, MapAccum, DelAccumulator, Inc, Dec;


$ENUM Vector;

/*

<CVector e.Name s.Method e.Args> == e.Result

e.Name, e.Args, e.Result ::= e.ANY-EXPR
s.Method ::= s.WORD?

*/
$ENTRY CVector {
  e.Name () =
    <Br e.Name '=' [Vector]>; 
  e.Name ("&" e.NameCopy) =
    <Cp e.NameCopy>: [Vector e.Vector] =
    <Br e.Name '=' [Vector e.Vector]>;
  e.Name ("&&" e.NameMove) =
    <Cp e.NameMove>: [Vector e.Vector] =
    <Br e.Name '=' [Vector e.Vector]>
    <Rp e.NameMove '=' [Vector]>;
  e.Name (s.Count e.Value) =
    <Br e.Name '=' [Vector <DoNewCount 0 s.Count e.Value>]>;   
  e.Name (e.InitList) =
    <Br e.Name '=' [Vector <DelAccumulator <MapAccum {s.Ind (e.Val) = <Inc s.Ind> (s.Ind e.Val)} 0 e.InitList>>]>;   
  e.Name "~" =
    <Cp e.Name>: [Vector e._] =
    <Rp e.Name '=' >;   
  e.Name "=&" e.NameCopy =
    <Cp e.NameCopy>: [Vector e.Vector] =
    <Cp e.Name>: [Vector e._] =
    <Rp e.Name '=' [Vector e.Vector]>;
  e.Name "=&&" e.NameMove =
    <Cp e.NameMove>: [Vector e.Vector] =
    <Cp e.Name>: [Vector e._] =
    <Rp e.Name '=' [Vector e.Vector]>
    <Rp e.NameMove '=' [Vector]>; 
  e.Name "=" e.InitList =
    <Cp e.Name>: [Vector e._] =
    <Rp e.Name '=' [Vector <DelAccumulator <MapAccum {s.Ind (e.Val) = <Inc s.Ind> (s.Ind e.Val)} 0 e.InitList>>]>;   
  e.Name Assign s.Count e.Value =
    <Cp e.Name>: [Vector e._] =
    <Rp e.Name '=' [Vector <DoNewCount 0 s.Count e.Value>]>;   
  e.Name Assign e.InitList =
    <Cp e.Name>: [Vector e._] =
    <Rp e.Name '=' [Vector <DelAccumulator <MapAccum {s.Ind (e.Val) = <Inc s.Ind> (s.Ind e.Val)} 0 e.InitList>>]>;     
  e.Name "&" =
    <Cp e.Name>: [Vector e.Vector] =
    <Map {(s.Ind e.Val) = (e.Val)} e.Vector>;
  e.Name "&&" =
    <Cp e.Name>: [Vector e.Vector] =
    <Map {(s.Ind e.Val) = (e.Val)} e.Vector>
    <Rp e.Name '=' [Vector]>;
  e.Name At s.Pos = 
    <Cp e.Name>:
    {
      [Vector e._ (s.Pos e.Value) e._] =
        e.Value;
      [Vector e._] =
        OUT_OF_RANGE
    };
  e.Name At s.Pos e.Value = 
    <Cp e.Name>:
    {
      [Vector e.Vector-B (s.Pos e._) e.Vector-E] =
        <Rp e.Name '=' [Vector e.Vector-B (s.Pos e.Value) e.Vector-E]>;
      [Vector e._] =
        OUT_OF_RANGE
    };  
  e.Name "[]" s.Pos =
    <Cp e.Name>: [Vector e._ (s.Pos e.Value) e._] =
    e.Value;
  e.Name "[]" s.Pos e.Value =
    <Cp e.Name>: [Vector e.Vector-B (s.Pos e._) e.Vector-E] =
    <Rp e.Name '=' [Vector e.Vector-B (s.Pos e.Value) e.Vector-E]>;
  e.Name Front =
    <Cp e.Name>: [Vector (0 e.Value) e._] =
    e.Value;
  e.Name Front e.Value =
    <Cp e.Name>: [Vector (0 e._) e.Vector-E] =
    <Rp e.Name '=' [Vector (0 e.Value) e.Vector-E]>;
  e.Name Back =
    <Cp e.Name>: [Vector e._ (s._ e.Value)] =
    e.Value;
  e.Name Back e.Value =
    <Cp e.Name>: [Vector e.Vector-B (s.Pos e._)] =
    <Rp e.Name '=' [Vector e.Vector-B (s.Pos e.Value)]>;
  e.Name Empty = 
    <Cp e.Name>:
    {
      [Vector] =
        True;
      [Vector e._] =
        False
    };  
  e.Name Size = 
    <Cp e.Name>:
    {
      [Vector] =
        0;
      [Vector e.Vector-B (s.Index e._)] =
        <Inc s.Index>
    }; 
  e.Name Clear =
    <Cp e.Name>: [Vector e._] =
    <Rp e.Name '=' [Vector]>;    
  e.Name Insert End (e.Value) =   
    <Cp e.Name>:
    {
      [Vector] =
        <Rp e.Name '=' [Vector (0 e.Value)]>;
      [Vector e.Vector-B (s.Pos e.Val)] =
        <Rp e.Name '=' [Vector e.Vector-B (s.Pos e.Val) (<Inc s.Pos> e.Value)]>
    };
  e.Name Insert s.Pos (e.Value) =   
    <Cp e.Name>: [Vector e.Vector-B (s.Pos e.PosValue) e.Vector-E] =
    <Rp e.Name '='
    [Vector
      e.Vector-B (s.Pos e.Value) (<Inc s.Pos> e.PosValue)
      <Map {(s.Ind e.Val) = (<Inc s.Ind> e.Val)} e.Vector-E>
    ]>;
  e.Name Insert End s.Count e.Value =   
    <Cp e.Name>:
    {
      [Vector] =
        <Rp e.Name '=' [Vector <DoNewCount 0 s.Count e.Value>]>;
      [Vector e.Vector-B (s.Pos e.Val)] =
        <Rp e.Name '='
          [Vector
            e.Vector-B (s.Pos e.Val)
            <Map {(s.Ind e.Val) = (<Inc <Add s.Ind s.Pos>> e.Val)} <DoNewCount 0 s.Count e.Value>>
          ]>
    };  
  e.Name Insert s.Pos s.Count e.Value =   
    <Cp e.Name>: [Vector e.Vector-B (s.Pos e.PosValue) e.Vector-E] =
    <Rp e.Name '=' 
      [Vector
        e.Vector-B 
        <Map {(s.Ind e.Val) = (<Add s.Ind s.Pos> e.Val)} <DoNewCount 0 s.Count e.Value>>
        (<Add s.Pos s.Count> e.PosValue) 
        <Map {(s.Ind e.Val) = (<Add s.Ind s.Count> e.Val)} e.Vector-E>
      ]>; 
  e.Name Insert End e.InitList =   
    <Cp e.Name>:
    {
      [Vector] =
        <Rp e.Name '='
          [Vector
            <DelAccumulator <MapAccum {s.Ind (e.Val) = <Inc s.Ind> (s.Ind e.Val)} 0 e.InitList>>
          ]>;
      [Vector e.Vector-B (s.Pos e.Val)] =
        <MapAccum {s.Ind (e.Val) = <Inc s.Ind> (s.Ind e.Val)} 0 e.InitList>: s._ e.InitVector =
        <Rp e.Name '='
          [Vector
            e.Vector-B (s.Pos e.Val)
            <Map {(s.Ind e.Val) = (<Inc <Add s.Ind s.Pos>> e.Val)} e.InitVector>
          ]>
    };    
  e.Name Insert s.Pos e.InitList =   
    <Cp e.Name>: [Vector e.Vector-B (s.Pos e.PosValue) e.Vector-E] =
    <MapAccum {s.Ind (e.Val) = <Inc s.Ind> (s.Ind e.Val)} 0 e.InitList>: s.Count e.InitVector =
    <Rp e.Name '=' 
      [Vector
        e.Vector-B 
        <Map {(s.Ind e.Val) = (<Add s.Ind s.Pos> e.Val)} e.InitVector>
        (<Add s.Pos s.Count> e.PosValue) 
        <Map {(s.Ind e.Val) = (<Add s.Ind s.Count> e.Val)} e.Vector-E>
      ]>;
  e.Name Erase End =
    <Cp e.Name>: [Vector e.Vector-B (s._ e._)] =
    <Rp e.Name '=' [Vector e.Vector-B]>;    
  e.Name Erase s.Pos =
    <Cp e.Name>: [Vector e.Vector-B (s.Pos e._) e.Vector-E] =
    <Rp e.Name '=' [Vector e.Vector-B <Map {(s.Ind e.Val) = (<Dec s.Ind> e.Val)} e.Vector-E>]>;
  e.Name Erase s.First End =
    <Cp e.Name>: [Vector e.Vector-B (s.First e._) e.Vector-E] =
    <Rp e.Name '=' [Vector e.Vector-B]>;  
  e.Name Erase s.First s.Last =
    <Cp e.Name>: [Vector e.Vector-B (s.First e._) e.Vector-M (s.Last e._) e.Vector-E] =
    <Rp e.Name '=' [Vector e.Vector-B <Map {(s.Ind e.Val) = (<Sub s.Ind <Inc <Sub s.Last s.First>>> e.Val)} e.Vector-E>]>;  
  e.Name Push_Back e.Value =   
    <Cp e.Name>:
    {
      [Vector] =
        <Rp e.Name '=' [Vector (0 e.Value)]>;
      [Vector e.Vector-B (s.Pos e.Val)] =
        <Rp e.Name '=' [Vector e.Vector-B (s.Pos e.Val) (<Inc s.Pos> e.Value)]>
    };
  e.Name Pop_Back =
    <Cp e.Name>: [Vector e.Vector-B (s._ e._)] =
    <Rp e.Name '=' [Vector e.Vector-B]>;  
}

DoNewCount {
  s.Count s.Count e._ =
    /* empty */;
  s.Index s.Count e.Value =
    (s.Index e.Value) <DoNewCount <Inc s.Index> s.Count e.Value>
}
