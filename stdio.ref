* Copyright 2023 Aleksandr Bocharov
* Distributed under the Boost Software License, Version 1.0.
* See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt
* 2023-05-21

/*

Модуль "stdio" написан на языке программирования Рефал-5-Лямбда.
https://github.com/bmstu-iu9/refal-5-lambda

Модуль "stdio" реализует некоторые функции ввода-вывод.

*/




%%
#include <stdio.h>
%%

/* 

<Putchar e.Char> == * empty *

e.Char ::= s.CHAR? | s.CHAR e.ANY-EXPR

*/
$ENTRY Putchar {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  int putchar_res = 0;
  refalrts::Iter p = content_b, end = content_e;
  
  if (! refalrts::empty_seq(p, end)) 
  {
    switch(p->tag) 
	{
      case refalrts::cDataChar:
        putchar_res = printf("%c", p->char_info);
		break;

      default:
	    return refalrts::cRecognitionImpossible;
    }
  }

  if (putchar_res < 0) 
  {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

/*

<Getchar> == s.Char

s.Char ::= s.CHAR

*/
$ENTRY Getchar {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);
	
  if (! refalrts::empty_seq(content_b, content_e)) 
  {
    return refalrts::cRecognitionImpossible;
  }
	
  refalrts::reset_allocator(vm);
  refalrts::Iter dummy = 0;

  int cur_char;
  cur_char = getchar();
  refalrts::alloc_char(vm, dummy, static_cast<char>(cur_char));

  refalrts::splice_from_freelist(vm, arg_begin);
  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

/*

<RU e.Chars> == e.NewChars

e.Chars, e.NewChars ::= s.CHAR*

*/
$ENTRY RU {
  /* empty */ = /* empty */;
  'Ё' e.RestChars =
    <Chr 240> <RU e.RestChars>;
  'ё' e.RestChars =
    <Chr 241> <RU e.RestChars>;
  s.Char1 s.Char2 e.RestChars,
  <isRU s.Char1 s.Char2>:208 =
    <Chr <Sub <Ord s.Char2> 16>> <RU e.RestChars>;
  s.Char1 s.Char2 e.RestChars,
  <isRU s.Char1 s.Char2>:209 =
    <Chr <Add <Ord s.Char2> 96>> <RU e.RestChars>;
  s.Char e.RestChars =
    s.Char <RU e.RestChars>;
}

/*

<isRU e.Char> == s.isRU

e.Char ::= s.CHAR s.CHAR
s.isRU ::= 208 | 209 | False

*/
$ENTRY isRU {
  e.Char,
  <Compare (<Ord e.Char>) 208 143>: '+',
  <Compare (<Ord e.Char>) 208 192>: '-' =
    208;
  e.Char,
  <Compare (<Ord e.Char>) 209 127>: '+',
  <Compare (<Ord e.Char>) 209 144>: '-' =
    209;
  e.Char =
    False
}
